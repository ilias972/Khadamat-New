generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum Role {
  CLIENT
  PRO
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
}

enum KycStatus {
  NOT_SUBMITTED
  PENDING
  APPROVED
  REJECTED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  DECLINED
  CANCELLED_BY_CLIENT
  CANCELLED_BY_CLIENT_LATE
  CANCELLED_BY_PRO
  CANCELLED_AUTO_FIRST_CONFIRMED
  CANCELLED_AUTO_OVERLAP
  EXPIRED
  WAITING_FOR_CLIENT
  COMPLETED
}

enum BookingEventType {
  CREATED
  CONFIRMED
  DECLINED
  EXPIRED
  CANCELLED
  COMPLETED
  SLOTS_RELEASED
}

enum SubscriptionPlan {
  PREMIUM_MONTHLY_NO_COMMIT
  PREMIUM_ANNUAL_COMMIT
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

enum BoostStatus {
  ACTIVE
  EXPIRED
}

enum EstimatedDuration {
  H1
  H2
  H3
  H4
  H8
}

enum PaymentProvider {
  MANUAL
  // STRIPE  // Future
  // PAYPAL  // Future
}

model City {
  id        String   @id @default(cuid())
  publicId  String   @unique
  name      String   @unique
  slug      String   @unique
  createdAt DateTime @default(now())

  users       User[]       @relation("UserCity")
  proProfiles ProProfile[]
  bookings    Booking[]
  boosts      ProBoost[]
}

model Category {
  id        String   @id @default(cuid())
  publicId  String   @unique
  name      String   @unique
  slug      String   @unique
  createdAt DateTime @default(now())

  proServices ProService[]
  bookings    Booking[]
  boosts      ProBoost[]
}

model User {
  id       String     @id @default(cuid())
  publicId String     @unique
  role     Role
  status   UserStatus @default(ACTIVE)

  phone     String  @unique
  email     String? @unique
  password  String
  firstName String
  lastName  String
  avatarUrl String?

  // Localisation CLIENT (pour validation géographique des bookings)
  cityId      String?
  city        City?   @relation("UserCity", fields: [cityId], references: [id])
  addressLine String? // Adresse précise (rue, numéro...)

  // CLIENT penalty system (PRD)
  clientLateCancelCount30d Int       @default(0)
  clientSanctionTier       Int       @default(0) // 0 none, 1=48h, 2=7d, 3=1m, 4=ban
  bookingCooldownUntil     DateTime?
  clientPenaltyResetAt     DateTime?

  // Ban audit (global)
  bannedAt  DateTime?
  banReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  proProfile       ProProfile?
  bookingsAsClient Booking[]      @relation("BookingsAsClient")
  reviewsAsClient  Review[]       @relation("ReviewsAsClient")
  refreshTokens      RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  favoritesAsClient  Favorite[]    @relation("FavoritesAsClient")
  favoritedAsPro     Favorite[]    @relation("FavoritesAsPro")
}

model ProProfile {
  userId   String @id
  publicId String @unique
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // MVP: PRO choisit UNE ville
  cityId String
  city   City   @relation(fields: [cityId], references: [id])

  // WhatsApp-first
  whatsapp String

  // Bio / description
  bio String?

  // KYC
  cinHash            String?   // SHA-256(cinNumber + salt) — never expose
  kycStatus          KycStatus @default(NOT_SUBMITTED)
  kycCinFrontKey     String?   // Private storage key — never expose
  kycCinBackKey      String?   // Private storage key — never expose
  kycSelfieKey       String?   // Private storage key — never expose
  kycRejectionReason String?

  // Premium (MVP flag simplifié)
  isPremium Boolean @default(false)

  // Subscription flags (source of truth via rows ci-dessous)
  premiumActiveUntil DateTime?
  boostActiveUntil   DateTime?

  // PRO penalty counters (PRD)
  proCancelCount30d         Int @default(0)
  proConsecutiveCancelCount Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  services           ProService[]
  bookings           Booking[]
  weeklyAvailability WeeklyAvailability[]
  subscriptions      ProSubscription[]
  boosts             ProBoost[]
  reviewsAsPro       Review[]              @relation("ReviewsAsPro")
  paymentOrders      PaymentOrder[]
  portfolio          ProPortfolioImage[]
}

model ProService {
  id         String   @id @default(cuid())
  proUserId  String
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
  isActive   Boolean  @default(true)

  // Affichage prix (fourchette ou fixe) — info profil, le prix final est négocié sur WhatsApp
  pricingType   String? // "RANGE" | "FIXED" (texte simple MVP)
  minPriceMad   Int?
  maxPriceMad   Int?
  fixedPriceMad Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pro ProProfile @relation(fields: [proUserId], references: [userId], onDelete: Cascade)

  @@unique([proUserId, categoryId])
  @@index([categoryId])
}

model Booking {
  id       String        @id @default(cuid())
  status   BookingStatus
  timeSlot DateTime

  cityId     String
  city       City     @relation(fields: [cityId], references: [id])
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  clientId String
  proId    String

  expiresAt   DateTime
  cancelledAt DateTime? // uniquement CANCELLED*
  completedAt DateTime?
  confirmedAt DateTime?

  // durée choisie à la confirmation (H1/H2/H3/H4/H8)
  estimatedDuration EstimatedDuration? @default(H1)

  // Durée en heures (pour modification PRO)
  duration Int @default(1)

  // Flag: Le PRO a-t-il modifié la demande ? (une seule fois max)
  isModifiedByPro Boolean @default(false)

  // raison annulation (obligatoire quand actor=PRO sur CONFIRMED)
  cancelReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  client User       @relation("BookingsAsClient", fields: [clientId], references: [id])
  pro    ProProfile @relation(fields: [proId], references: [userId])

  // Relations
  events BookingEvent[]
  review Review?

  @@index([clientId, cityId, categoryId, timeSlot])
  @@index([clientId])
  @@index([proId, timeSlot])
  @@index([proId])
  @@index([proId, status, timeSlot])
}

model BookingEvent {
  id        String           @id @default(cuid())
  bookingId String
  type      BookingEventType

  actorUserId String? // null si SYSTEM
  actorRole   Role?
  metadata    Json?

  createdAt DateTime @default(now())

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId, createdAt])
}

model WeeklyAvailability {
  id        String @id @default(cuid())
  proUserId String

  // 0=Dimanche … 6=Samedi (standard JS)
  dayOfWeek Int

  // minutes depuis 00:00 (ex: 9h00 = 540)
  startMin Int
  endMin   Int

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pro ProProfile @relation(fields: [proUserId], references: [userId], onDelete: Cascade)

  @@unique([proUserId, dayOfWeek])
}

model Review {
  id        String @id @default(cuid())
  bookingId String @unique

  clientId String
  proId    String

  rating  Int // 1..5
  comment String?

  createdAt DateTime @default(now())

  booking Booking    @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  client  User       @relation("ReviewsAsClient", fields: [clientId], references: [id], onDelete: Cascade)
  pro     ProProfile @relation("ReviewsAsPro", fields: [proId], references: [userId], onDelete: Cascade)

  @@index([proId, createdAt])
}

model ProSubscription {
  id        String @id @default(cuid())
  proUserId String

  plan   SubscriptionPlan
  status SubscriptionStatus @default(ACTIVE)

  // Stripe
  stripeCustomerId     String?
  stripeSubscriptionId String?

  // engagement annuel (plan PREMIUM_ANNUAL_COMMIT)
  commitmentStartsAt DateTime?
  commitmentEndsAt   DateTime?

  // pricing snapshot
  priceMad         Int
  introDiscountMad Int? // -50 MAD premier mois

  startedAt DateTime  @default(now())
  endedAt   DateTime?

  pro           ProProfile @relation(fields: [proUserId], references: [userId], onDelete: Cascade)
  transactionId String?

  @@index([proUserId, status])
}

model ProBoost {
  id        String @id @default(cuid())
  proUserId String

  // ciblage
  cityId     String
  city       City     @relation(fields: [cityId], references: [id])
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  status BoostStatus @default(ACTIVE)

  // semaine glissante
  startsAt DateTime
  endsAt   DateTime

  // Stripe
  stripePaymentIntentId String?

  // pricing snapshot
  priceMad Int @default(200)

  createdAt DateTime @default(now())

  pro ProProfile @relation(fields: [proUserId], references: [userId], onDelete: Cascade)

  @@index([cityId, categoryId, status, startsAt])
  @@index([proUserId, endsAt])
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  tokenHash String   @unique // SHA-256 hash du refresh token (jamais le token brut)
  revoked   Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  tokenHash String    @unique
  userId    String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

enum PaymentOrderPlanType {
  PREMIUM_MONTHLY
  PREMIUM_ANNUAL
  BOOST
}

enum PaymentOrderStatus {
  PENDING
  PAID
  FAILED
}

model PaymentOrder {
  id  String @id @default(cuid())
  oid String @unique // Référence unique de commande

  proUserId String
  pro       ProProfile @relation(fields: [proUserId], references: [userId], onDelete: Cascade)

  planType PaymentOrderPlanType
  provider PaymentProvider      @default(MANUAL)

  // Montant en CENTIMES (évite erreurs Float)
  amountCents Int

  status PaymentOrderStatus @default(PENDING)

  // Metadata Boost (optionnel)
  cityId     String?
  categoryId String?

  // Notes admin (pour paiement manuel)
  adminNotes String?

  createdAt DateTime  @default(now())
  paidAt    DateTime?

  @@index([proUserId, status])
  @@index([oid])
}

model KycAccessLog {
  id        String   @id @default(uuid())
  userId    String
  filename  String
  result    String
  ip        String
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}

enum NewsletterStatus {
  PENDING
  ACTIVE
  UNSUBSCRIBED
}

model NewsletterSubscriber {
  id             String           @id @default(uuid())
  email          String           @unique
  status         NewsletterStatus @default(PENDING)
  token          String
  ip             String?
  userAgent      String?
  createdAt      DateTime         @default(now())
  tokenCreatedAt DateTime         @default(now())
  confirmedAt    DateTime?

  @@index([token])
}

model ProPortfolioImage {
  id        String     @id @default(cuid())
  proUserId String
  pro       ProProfile @relation(fields: [proUserId], references: [userId], onDelete: Cascade)
  url       String
  createdAt DateTime   @default(now())

  @@index([proUserId])
}

model Favorite {
  id        String   @id @default(cuid())
  clientId  String
  proId     String
  createdAt DateTime @default(now())

  client User @relation("FavoritesAsClient", fields: [clientId], references: [id], onDelete: Cascade)
  pro    User @relation("FavoritesAsPro", fields: [proId], references: [id], onDelete: Cascade)

  @@unique([clientId, proId])
  @@index([clientId])
  @@index([proId])
}
